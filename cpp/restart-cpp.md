# 0.1~0.4
## 程序和编程语言简介
### 什么是程序
是可以被执行的文件
- 为什么可以执行文件
因为这个文件的内部结构由对应架构支持的指令集组成，当执行这个程序的时候，实际调用的是这个二进制的接口，随后调用到这个文件内其他可执行指令，进而达成这个程序的目标。
- 什么是对应架构，架构的指令集又是什么
实际上这和cpu这个硬件相关，cpu是中央处理器，它的上面有无数的电阻电路，电阻电路的规则组合对应着一些可以被直接执行的`固定程序`，这些所谓的固定程序就是指令集，指令集可以被开发者调用，用来调度资源，进行一些或基础或复杂的计算。我们只能用指令集来实现更复杂的算法，不能改变指令集，指令集的固定性和规范化，就是一个固定的架构。至今已经有很多架构了，如英特尔的x86，amd的arm，当然，这只是cpu的架构。
- 为什么要区分指令集，直接弄一套最高效的不就好了么？
这是目标，但是就目前的技术而言还达不到，所以开发人员在尝试找一个平衡点。较为热的两种指令集也代表了两种不同的观念，即LSI和SSI，即长指令集和短指令集。
- 长短指令集为什么要存在呢，他们有什么区别？
长指令集以英特尔的x86架构为代表，其基础指令集可能较长，类比来说，就是intel把函数当做了指令而不是基础的四则运算。优点显而易见，x86可以更快的更好的进行更复杂的计算，单指令在内存的排列更加的密集，计算时上下文相关性更强。但随之而来的就是会造成内存的碎片化，即长指令的变多，会导致内存利用率变低。arm用的是更加灵活的短指令，其指令集更加的基础，不会进行一些额外计算，指哪打哪。所以目前x86架构的都是一些家用电脑，而arm的设备大多为移动端设备。arm指令集的特性在移动端的体现就是更省电，小内存更友好。不过随着硬件的发展，是否会出现一款更平衡更适配硬件的架构呢？所以说是架构适配了硬件，还是硬件在追赶架构？都有吧。

### 什么编程语言
是将离架构指令集更远的代码变成cpu可以认识的指令集的工具
- 什么叫离架构更远？
因为历史原因，架构可以认识的指令实际上是由1和0组成的数串，人类通过这种复杂的数串来实现需要的功能实在是太过复杂了，要是想更好地复用更好的读懂前人的成果必须要有一个类似`白话文`的东西出现，高级语言也就诞生了。以C语言为例，其关键字和语法都遵循着一定的英文语法，让程序具有更好的可读性。但人是好识别了，会写了，cpu怎么认识呢？这就是编译器的功能，它会一层一层的解系高级语言(C语言)，最后将整个程序解释成一个可执行文件，里面都是对应架构可执行的指令。这就是编译器要干的活。
- 你提到了`高级语言`，意思是越高离架构就越远？
哈哈哈，这是个很有意思的问题。抽象是相对的，对于人类越好认，对于机器就越抽象，可能解释起来就越麻烦。高级语言已经找到了一个相对很好的平衡点，即让人类好认，编译器又可以很好的进行翻译。所以这里的`高`可以理解为架构指令集远，但并不一定是越远越高级，也不一定越低级就越好认。
- 照你这么说，在所谓的高级语言和指令集之间有很长距离了，中间发生了什么？
这个问题太过于庞大了，但这也是编译器的核心所在。编译器会把高级语言进行`替换和擦除`，替换指的是原来程序中的一些宏定义，需要被替换成可以被编译器处理的高级语言，擦除指的是注释是不必要的，需要被擦除。随之而来的就是语法分析、语义分析、词法分析，这期间会对你书写程序的正确性进行check，随后对其进行token化，然后将其解释为ast(抽象语法树)。再后来，编译器会把ast解释为IR，对IR做很多非常经典的优化，优化后的IR会被解释为CFG(有向无环图)，他将本就是SSA的IR转换为更加贴合汇编指令的单条形式，随后解释其为汇编。汇编其实已经很贴近指令集，这里还差汇编器的处理，将其彻底处理为`.o`文件。实际上`.o`文件已经可以被cpu识别，只是可能它缺少入口或者还不完整，随后链接器就出马了，将不同部分的c代码编译成的.o文件链接成一个可执行文件，这就是大体的过程。
- 哇，高级语言居然离指令集这么远，那是不是所有的编译器就都是这样的呢？
虽然这个结构经典到爆炸了，不过编译器不单有这一种，从大类上分，编译器有aot和jit，我上面说的是一种aot编译器。aot除了经典的llvm架构，还有混沌但是优化非常极限的gcc。JIT是解释执行，他会直接将高级语言翻译成可执行的的指令让cpu运行。
- 这两种编译器的优劣是什么呢？
改天回复你，我累了。